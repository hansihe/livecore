use serde::{Deserialize, Serialize};

use crate::{Connector, Challenge, ChallengeResponse, Uuid, Hash, impl_from};

/// Sent by the server after it has received a `ClientHandshake`.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[cfg_attr(feature = "jsonschema", derive(JsonSchema))]
pub struct ServerHandshake {
    /// UUID assigned to the client for the fabric session.
    pub client_uuid: Uuid,

    /// For the duration of the fabric session, the orchestrator will
    /// have a single keypair. This is the public key for that pair.
    pub pubkey: Vec<u8>,

    pub challenge: Challenge,
    pub challenge_response: ChallengeResponse,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[cfg_attr(feature = "jsonschema", derive(JsonSchema))]
pub struct ConnectPeer {
    pub connector: Connector,

    /// The UUID of the peer we should connect to in the fabric.
    pub peer_uuid: Uuid,
    /// The pubkey of the peer node.
    pub peer_pubkey: Vec<u8>,

    /// `self_nonce` and `peer_nonce` are UUIDs generated by the orchestrator
    /// that are unique, random, and only used for this handshake.
    ///
    /// These are only known by this node and the connecting peer, and can be
    /// used for any purpose depending on the transport used.
    pub self_nonce: Uuid,
    pub peer_nonce: Uuid,
}

/// Used in tests, makes the client process disconnect and exit.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[cfg_attr(feature = "jsonschema", derive(JsonSchema))]
pub struct TestExit {}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[cfg_attr(feature = "jsonschema", derive(JsonSchema))]
pub struct FragmentManifest {
    pub hash: Hash,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[cfg_attr(feature = "jsonschema", derive(JsonSchema))]
pub struct ObjectManifest {
    pub hash: Hash,
    pub tags: Vec<String>,
    pub size: usize,
    pub fragment_size: u32,
    pub fragments: Vec<FragmentManifest>,
}

// TODO: Fix copying on deserializing Cow
// https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=418dd6b98dfa62d43c4cc7fa8b7ea0d6

#[derive(Serialize, Deserialize, Debug, Clone)]
#[cfg_attr(feature = "jsonschema", derive(JsonSchema))]
#[serde(tag = "ty", rename_all = "snake_case")]
pub enum OrchServerMsg {
    ServerHandshake(ServerHandshake),

    TestExit(TestExit),

    ObjectManifest(ObjectManifest),

    ConnectPeer(ConnectPeer),
}
impl OrchServerMsg {
    pub fn serialize(&self) -> serde_json::Result<Vec<u8>> {
        serde_json::to_vec(self)
    }
    pub fn deserialize(string: &[u8]) -> serde_json::Result<Self> {
        serde_json::from_slice(string)
    }
}
impl_from!(OrchServerMsg, ServerHandshake, ServerHandshake);
